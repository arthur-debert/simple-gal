//! Browser layout tests — verifies CSS/HTML rendering of generated gallery pages.
//!
//! These tests use headless Chrome to load real HTML generated by the Rust pipeline
//! and assert on computed bounding boxes, scroll metrics, and element positions.
//!
//! Run with: `cargo test --test browser_layout -- --ignored`

use headless_chrome::{Browser, LaunchOptions, Tab};
use serde::Deserialize;
use std::path::PathBuf;
use std::process::Command;
use std::sync::{Arc, OnceLock};

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

#[derive(Debug, Deserialize)]
struct BoundingBox {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
}

// ---------------------------------------------------------------------------
// Page paths (mirrors the Playwright `pages` registry)
// ---------------------------------------------------------------------------

mod page {
    pub mod no_description {
        pub const LANDSCAPE: &str = "No-Description/1-landscape/index.html";
    }
    pub mod with_caption {
        pub const LANDSCAPE: &str = "With-Caption/1-landscape/index.html";
        pub const PORTRAIT: &str = "With-Caption/2-portrait/index.html";
    }
    pub mod with_description {
        pub const LANDSCAPE: &str = "With-Description/1-landscape/index.html";
    }
}

// ---------------------------------------------------------------------------
// Setup helpers
// ---------------------------------------------------------------------------

fn generated_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/browser/generated")
}

fn ensure_fixtures_built() {
    static BUILT: OnceLock<()> = OnceLock::new();
    BUILT.get_or_init(|| {
        let bin = env!("CARGO_BIN_EXE_simple-gal");
        let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let status = Command::new(bin)
            .args([
                "build",
                "--source",
                root.join("fixtures/browser-content").to_str().unwrap(),
                "--output",
                root.join("tests/browser/generated").to_str().unwrap(),
                "--temp-dir",
                root.join(".simple-gal-browser-temp").to_str().unwrap(),
            ])
            .status()
            .expect("failed to run simple-gal");
        assert!(status.success(), "fixture generation failed");
    });
}

fn browser() -> &'static Browser {
    static B: OnceLock<Browser> = OnceLock::new();
    B.get_or_init(|| {
        Browser::new(LaunchOptions {
            window_size: Some((1280, 800)),
            ..Default::default()
        })
        .expect("failed to launch Chrome")
    })
}

fn set_viewport(tab: &Tab, width: u32, height: u32) {
    use headless_chrome::protocol::cdp::Emulation::SetDeviceMetricsOverride;
    tab.call_method(SetDeviceMetricsOverride {
        width,
        height,
        device_scale_factor: 1.0,
        mobile: false,
        scale: None,
        screen_width: None,
        screen_height: None,
        position_x: None,
        position_y: None,
        dont_set_visible_size: None,
        screen_orientation: None,
        viewport: None,
        display_feature: None,
        device_posture: None,
    })
    .unwrap();
}

fn load_page_with_viewport(
    path: &str,
    css_overrides: &[(&str, &str)],
    vw: u32,
    vh: u32,
) -> Arc<Tab> {
    ensure_fixtures_built();
    let tab = browser().new_tab().unwrap();
    set_viewport(&tab, vw, vh);

    let file = generated_dir().join(path);
    assert!(file.exists(), "missing: {}", file.display());

    tab.navigate_to(&format!("file://{}", file.display()))
        .unwrap()
        .wait_until_navigated()
        .unwrap();

    if !css_overrides.is_empty() {
        let vars: String = css_overrides
            .iter()
            .map(|(k, v)| format!("{k}: {v} !important;"))
            .collect::<Vec<_>>()
            .join(" ");
        tab.evaluate(
            &format!(
                "{{ const s=document.createElement('style'); \
                 s.textContent=':root {{ {vars} }}'; \
                 document.head.appendChild(s); }}"
            ),
            false,
        )
        .unwrap();
    }

    tab
}

fn load_page(path: &str, css_overrides: &[(&str, &str)]) -> Arc<Tab> {
    load_page_with_viewport(path, css_overrides, 1280, 800)
}

fn bounding_box(tab: &Tab, selector: &str) -> BoundingBox {
    let js = format!(
        "var _r = document.querySelector('{selector}').getBoundingClientRect(); \
         JSON.stringify({{ x: _r.x, y: _r.y, width: _r.width, height: _r.height }})"
    );
    let obj = tab.evaluate(&js, false).unwrap();
    serde_json::from_str(obj.value.unwrap().as_str().unwrap()).unwrap()
}

fn assert_close(actual: f64, expected: f64, tolerance: f64) {
    assert!(
        (actual - expected).abs() <= tolerance,
        "expected {actual} ≈ {expected} (±{tolerance}), diff = {}",
        (actual - expected).abs()
    );
}

// ===========================================================================
// No description
// ===========================================================================

#[test]
#[ignore]
fn no_description_image_frame_fills_space() {
    let tab = load_page(page::no_description::LANDSCAPE, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    assert!(frame.width > 100.0);
    assert!(frame.height > 100.0);
}

// ===========================================================================
// Short caption
// ===========================================================================

#[test]
#[ignore]
fn short_caption_width_matches_frame() {
    let tab = load_page(page::with_caption::LANDSCAPE, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert_close(caption.width, frame.width, 0.5);
}

#[test]
#[ignore]
fn short_caption_below_frame() {
    let tab = load_page(page::with_caption::LANDSCAPE, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert!(caption.y >= frame.y + frame.height - 1.0);
}

#[test]
#[ignore]
fn short_caption_within_frame_width_portrait() {
    let tab = load_page(page::with_caption::PORTRAIT, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert!(caption.width <= frame.width + 1.0);
}

#[test]
#[ignore]
fn short_caption_centered_with_frame() {
    let tab = load_page(page::with_caption::PORTRAIT, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    let frame_cx = frame.x + frame.width / 2.0;
    let caption_cx = caption.x + caption.width / 2.0;
    assert_close(caption_cx, frame_cx, 0.5);
}

// ===========================================================================
// Long description
// ===========================================================================

#[test]
#[ignore]
fn long_desc_within_viewport() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let desc = bounding_box(&tab, ".image-description");
    let vh: f64 = tab
        .evaluate("window.innerHeight", false)
        .unwrap()
        .value
        .unwrap()
        .as_f64()
        .unwrap();
    assert!(desc.y < vh, "description should start within viewport");
    assert!(
        desc.y + desc.height <= vh + 1.0,
        "description should be contained within viewport (scrolls internally)"
    );
}

#[test]
#[ignore]
fn long_desc_scrolls_internally() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let overflows = tab
        .evaluate(
            "(() => { const d = document.querySelector('.image-description'); \
             return d.scrollHeight > d.clientHeight; })()",
            false,
        )
        .unwrap()
        .value
        .unwrap()
        .as_bool()
        .unwrap();
    assert!(overflows, "description should scroll internally");
}

#[test]
#[ignore]
fn long_desc_below_image_area() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let image_page = bounding_box(&tab, ".image-page");
    let desc = bounding_box(&tab, ".image-description");
    assert!(desc.y >= image_page.y + image_page.height - 1.0);
}

// ===========================================================================
// Viewport variations
// ===========================================================================

#[test]
#[ignore]
fn caption_matches_frame_narrow_viewport() {
    let tab = load_page_with_viewport(page::with_caption::LANDSCAPE, &[], 375, 667);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert_close(caption.width, frame.width, 0.5);
}

// ===========================================================================
// Image navigation dots
// ===========================================================================

#[test]
#[ignore]
fn nav_dots_visible() {
    let tab = load_page(page::with_caption::LANDSCAPE, &[]);
    let dot = bounding_box(&tab, ".image-nav a");
    assert!(
        dot.width >= 8.0,
        "dot should have visible width, got {}",
        dot.width
    );
    assert!(
        dot.height >= 8.0,
        "dot should have visible height, got {}",
        dot.height
    );
}

#[test]
#[ignore]
fn nav_dots_within_viewport() {
    let tab = load_page(page::no_description::LANDSCAPE, &[]);
    let nav = bounding_box(&tab, ".image-nav");
    let vh: f64 = tab
        .evaluate("window.innerHeight", false)
        .unwrap()
        .value
        .unwrap()
        .as_f64()
        .unwrap();
    assert!(
        nav.y + nav.height <= vh + 1.0,
        "nav dots should be within viewport, bottom={} vh={}",
        nav.y + nav.height,
        vh
    );
    assert!(nav.height > 0.0, "nav should have non-zero height");
}
