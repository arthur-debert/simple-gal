//! Browser layout tests — verifies CSS/HTML rendering of generated gallery pages.
//!
//! These tests use headless Chrome to load real HTML generated by the Rust pipeline
//! and assert on computed bounding boxes, scroll metrics, and element positions.
//!
//! Run with: `cargo test --test browser_layout -- --ignored`

use headless_chrome::{Browser, LaunchOptions, Tab};
use serde::Deserialize;
use std::path::PathBuf;
use std::process::Command;
use std::sync::{Arc, OnceLock};

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

#[derive(Debug, Deserialize)]
struct BoundingBox {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
}

// ---------------------------------------------------------------------------
// Page paths (mirrors the Playwright `pages` registry)
// ---------------------------------------------------------------------------

mod page {
    pub mod no_description {
        pub const LANDSCAPE: &str = "No-Description/1-landscape/index.html";
    }
    pub mod with_caption {
        pub const LANDSCAPE: &str = "With-Caption/1-landscape/index.html";
        pub const PORTRAIT: &str = "With-Caption/2-portrait/index.html";
    }
    pub mod with_description {
        pub const LANDSCAPE: &str = "With-Description/1-landscape/index.html";
    }
}

// ---------------------------------------------------------------------------
// Setup helpers
// ---------------------------------------------------------------------------

fn generated_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/browser/generated")
}

fn ensure_fixtures_built() {
    static BUILT: OnceLock<()> = OnceLock::new();
    BUILT.get_or_init(|| {
        let bin = env!("CARGO_BIN_EXE_simple-gal");
        let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let status = Command::new(bin)
            .args([
                "build",
                "--source",
                root.join("fixtures/browser-content").to_str().unwrap(),
                "--output",
                root.join("tests/browser/generated").to_str().unwrap(),
                "--temp-dir",
                root.join(".simple-gal-browser-temp").to_str().unwrap(),
            ])
            .status()
            .expect("failed to run simple-gal");
        assert!(status.success(), "fixture generation failed");
    });
}

fn browser() -> &'static Browser {
    static B: OnceLock<Browser> = OnceLock::new();
    B.get_or_init(|| {
        Browser::new(LaunchOptions {
            window_size: Some((1280, 800)),
            ..Default::default()
        })
        .expect("failed to launch Chrome")
    })
}

fn set_viewport(tab: &Tab, width: u32, height: u32) {
    use headless_chrome::protocol::cdp::Emulation::SetDeviceMetricsOverride;
    tab.call_method(SetDeviceMetricsOverride {
        width,
        height,
        device_scale_factor: 1.0,
        mobile: false,
        scale: None,
        screen_width: None,
        screen_height: None,
        position_x: None,
        position_y: None,
        dont_set_visible_size: None,
        screen_orientation: None,
        viewport: None,
        display_feature: None,
        device_posture: None,
    })
    .unwrap();
}

fn load_page_with_viewport(
    path: &str,
    css_overrides: &[(&str, &str)],
    vw: u32,
    vh: u32,
) -> Arc<Tab> {
    ensure_fixtures_built();
    let tab = browser().new_tab().unwrap();
    set_viewport(&tab, vw, vh);

    let file = generated_dir().join(path);
    assert!(file.exists(), "missing: {}", file.display());

    tab.navigate_to(&format!("file://{}", file.display()))
        .unwrap()
        .wait_until_navigated()
        .unwrap();

    if !css_overrides.is_empty() {
        let vars: String = css_overrides
            .iter()
            .map(|(k, v)| format!("{k}: {v} !important;"))
            .collect::<Vec<_>>()
            .join(" ");
        tab.evaluate(
            &format!(
                "{{ const s=document.createElement('style'); \
                 s.textContent=':root {{ {vars} }}'; \
                 document.head.appendChild(s); }}"
            ),
            false,
        )
        .unwrap();
    }

    tab
}

fn load_page(path: &str, css_overrides: &[(&str, &str)]) -> Arc<Tab> {
    load_page_with_viewport(path, css_overrides, 1280, 800)
}

fn bounding_box(tab: &Tab, selector: &str) -> BoundingBox {
    let js = format!(
        "var _r = document.querySelector('{selector}').getBoundingClientRect(); \
         JSON.stringify({{ x: _r.x, y: _r.y, width: _r.width, height: _r.height }})"
    );
    let obj = tab.evaluate(&js, false).unwrap();
    serde_json::from_str(obj.value.unwrap().as_str().unwrap()).unwrap()
}

fn assert_close(actual: f64, expected: f64, tolerance: f64) {
    assert!(
        (actual - expected).abs() <= tolerance,
        "expected {actual} ≈ {expected} (±{tolerance}), diff = {}",
        (actual - expected).abs()
    );
}

// ===========================================================================
// No description
// ===========================================================================

#[test]
#[ignore]
fn no_description_image_frame_fills_space() {
    let tab = load_page(page::no_description::LANDSCAPE, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    assert!(frame.width > 100.0);
    assert!(frame.height > 100.0);
}

// ===========================================================================
// Short caption
// ===========================================================================

#[test]
#[ignore]
fn short_caption_width_matches_frame() {
    let tab = load_page(page::with_caption::LANDSCAPE, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert_close(caption.width, frame.width, 0.5);
}

#[test]
#[ignore]
fn short_caption_below_frame() {
    let tab = load_page(page::with_caption::LANDSCAPE, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert!(caption.y >= frame.y + frame.height - 1.0);
}

#[test]
#[ignore]
fn short_caption_within_mat_width_portrait() {
    let tab = load_page(page::with_caption::PORTRAIT, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert!(caption.width <= frame.width + 1.0);
}

#[test]
#[ignore]
fn short_caption_centered_with_frame() {
    let tab = load_page(page::with_caption::PORTRAIT, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    let frame_cx = frame.x + frame.width / 2.0;
    let caption_cx = caption.x + caption.width / 2.0;
    assert_close(caption_cx, frame_cx, 0.5);
}

// ===========================================================================
// Long description — scrolls with photo, teaser peeks above nav dots
// ===========================================================================

#[test]
#[ignore]
fn long_desc_teaser_visible() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let desc = bounding_box(&tab, ".image-description");
    let vh: f64 = tab
        .evaluate("window.innerHeight", false)
        .unwrap()
        .value
        .unwrap()
        .as_f64()
        .unwrap();
    // Description teaser should start within viewport
    assert!(
        desc.y < vh,
        "description teaser should start within viewport, desc.y={} vh={}",
        desc.y,
        vh
    );
    // But full description extends beyond (needs scrolling)
    assert!(
        desc.y + desc.height > vh,
        "full description should extend beyond viewport"
    );
}

#[test]
#[ignore]
fn long_desc_main_scrollable() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let overflows = tab
        .evaluate(
            "(() => { const m = document.querySelector('main'); \
             return m.scrollHeight > m.clientHeight; })()",
            false,
        )
        .unwrap()
        .value
        .unwrap()
        .as_bool()
        .unwrap();
    assert!(
        overflows,
        "main should be scrollable when description is long"
    );
}

#[test]
#[ignore]
fn long_desc_photo_and_text_scroll_together() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let before_y = bounding_box(&tab, ".image-frame").y;

    // Scroll main down
    tab.evaluate("document.querySelector('main').scrollBy(0, 100)", false)
        .unwrap();
    std::thread::sleep(std::time::Duration::from_millis(100));

    let after_y = bounding_box(&tab, ".image-frame").y;
    assert!(
        after_y < before_y - 50.0,
        "image should scroll with description, before={before_y} after={after_y}"
    );
}

#[test]
#[ignore]
fn long_desc_below_mat() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let image_page = bounding_box(&tab, ".image-page");
    let desc = bounding_box(&tab, ".image-description");
    // Description starts after image-page + its bottom margin (mat)
    assert!(
        desc.y >= image_page.y + image_page.height,
        "description should be below the matted photo area"
    );
}

#[test]
#[ignore]
fn nav_dots_visible_with_description() {
    let tab = load_page(page::with_description::LANDSCAPE, &[]);
    let nav = bounding_box(&tab, ".image-nav");
    let vh: f64 = tab
        .evaluate("window.innerHeight", false)
        .unwrap()
        .value
        .unwrap()
        .as_f64()
        .unwrap();
    assert!(
        nav.y + nav.height <= vh + 1.0,
        "nav dots should be visible within viewport, bottom={} vh={}",
        nav.y + nav.height,
        vh
    );
    assert!(nav.height > 0.0, "nav should have non-zero height");
}

// ===========================================================================
// Viewport variations
// ===========================================================================

#[test]
#[ignore]
fn caption_matches_frame_narrow_viewport() {
    let tab = load_page_with_viewport(page::with_caption::LANDSCAPE, &[], 375, 667);
    let frame = bounding_box(&tab, ".image-frame");
    let caption = bounding_box(&tab, ".image-caption");
    assert_close(caption.width, frame.width, 0.5);
}

// ===========================================================================
// Image navigation dots
// ===========================================================================

#[test]
#[ignore]
fn nav_dots_visible() {
    let tab = load_page(page::with_caption::LANDSCAPE, &[]);
    let dot = bounding_box(&tab, ".image-nav a");
    assert!(
        dot.width >= 8.0,
        "dot should have visible width, got {}",
        dot.width
    );
    assert!(
        dot.height >= 8.0,
        "dot should have visible height, got {}",
        dot.height
    );
}

#[test]
#[ignore]
fn nav_dots_within_viewport() {
    let tab = load_page(page::no_description::LANDSCAPE, &[]);
    let nav = bounding_box(&tab, ".image-nav");
    let vh: f64 = tab
        .evaluate("window.innerHeight", false)
        .unwrap()
        .value
        .unwrap()
        .as_f64()
        .unwrap();
    assert!(
        nav.y + nav.height <= vh + 1.0,
        "nav dots should be within viewport, bottom={} vh={}",
        nav.y + nav.height,
        vh
    );
    assert!(nav.height > 0.0, "nav should have non-zero height");
}

#[test]
#[ignore]
fn nav_dots_bottom_anchored_no_description() {
    let tab = load_page(page::no_description::LANDSCAPE, &[]);
    let nav = bounding_box(&tab, ".image-nav");
    let vh: f64 = tab
        .evaluate("window.innerHeight", false)
        .unwrap()
        .value
        .unwrap()
        .as_f64()
        .unwrap();

    // Nav should be in the bottom 25% of the viewport
    assert!(
        nav.y > vh * 0.75,
        "nav should be in bottom quarter of viewport, nav.y={} threshold={}",
        nav.y,
        vh * 0.75
    );
}

#[test]
#[ignore]
fn nav_dots_below_image_no_description() {
    let tab = load_page(page::no_description::LANDSCAPE, &[]);
    let nav = bounding_box(&tab, ".image-nav");
    let frame = bounding_box(&tab, ".image-frame");
    assert!(
        nav.y >= frame.y + frame.height - 1.0,
        "nav dots should be below image, nav.y={} frame_bottom={}",
        nav.y,
        frame.y + frame.height
    );
}

#[test]
#[ignore]
fn nav_dots_bottom_anchored_with_caption() {
    let tab = load_page(page::with_caption::LANDSCAPE, &[]);
    let nav = bounding_box(&tab, ".image-nav");
    let vh: f64 = tab
        .evaluate("window.innerHeight", false)
        .unwrap()
        .value
        .unwrap()
        .as_f64()
        .unwrap();

    // Nav should be in the bottom 25% of the viewport
    assert!(
        nav.y > vh * 0.75,
        "nav should be in bottom quarter of viewport, nav.y={} threshold={}",
        nav.y,
        vh * 0.75
    );
}

// ===========================================================================
// Navigation click zones overlap with image edges
// ===========================================================================

#[test]
#[ignore]
fn nav_zones_overlap_image_portrait_wide_viewport() {
    // Wide viewport + portrait image: the image is narrow and centered,
    // so the click zones should extend from the page edges into the image.
    let tab = load_page_with_viewport(page::with_caption::PORTRAIT, &[], 1920, 1080);
    let frame = bounding_box(&tab, ".image-frame");
    let prev = bounding_box(&tab, ".nav-prev");
    let next = bounding_box(&tab, ".nav-next");
    let vw: f64 = 1920.0;
    let overlap = 0.2;

    let expected_prev_right = frame.x + frame.width * overlap;
    let expected_next_left = frame.x + frame.width * (1.0 - overlap);

    // .nav-prev: left edge at 0, right edge 20% into the image
    assert_close(prev.x, 0.0, 1.0);
    assert_close(prev.x + prev.width, expected_prev_right, 2.0);

    // .nav-next: left edge at 80% of image, right edge at viewport edge
    assert_close(next.x, expected_next_left, 2.0);
    assert_close(next.x + next.width, vw, 2.0);
}

#[test]
#[ignore]
fn nav_zones_overlap_image_landscape() {
    let tab = load_page(page::no_description::LANDSCAPE, &[]);
    let frame = bounding_box(&tab, ".image-frame");
    let prev = bounding_box(&tab, ".nav-prev");
    let next = bounding_box(&tab, ".nav-next");
    let vw: f64 = 1280.0;
    let overlap = 0.2;

    let expected_prev_right = frame.x + frame.width * overlap;
    let expected_next_left = frame.x + frame.width * (1.0 - overlap);

    // .nav-prev: left edge at 0, right edge 20% into the image
    assert_close(prev.x, 0.0, 1.0);
    assert_close(prev.x + prev.width, expected_prev_right, 2.0);

    // .nav-next: left edge at 80% of image, right edge at viewport edge
    assert_close(next.x, expected_next_left, 2.0);
    assert_close(next.x + next.width, vw, 2.0);
}
